"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Playlist = void 0;
const __1 = require("..");
// TODO: Remove ! on the next major version
/**
 * Class representing a playlist.
 * @prop {string} source Playlist source
 * @template T - The type for the metadata (if any) of the playlist
 */
class Playlist {
    constructor(playlist, options = {}, props = {}, meta) {
        var _a;
        if ((0, __1.isMemberInstance)(options)) {
            process.emitWarning("Passing GuildMember for DisTube#Playlist() is deprecated, read the docs for more.", "DeprecationWarning");
            return new Playlist(playlist, { member: options, properties: props, metadata: meta });
        }
        const { member, properties, metadata } = Object.assign({ properties: {} }, options);
        if (typeof playlist !== "object") {
            throw new __1.DisTubeError("INVALID_TYPE", ["Array<Song>", "object"], playlist, "playlist");
        }
        if (typeof properties !== "object") {
            throw new __1.DisTubeError("INVALID_TYPE", "object", properties, "properties");
        }
        // FIXME
        const info = playlist;
        /**
         * The source of the playlist
         * @type {string}
         */
        this.source = (info.source || properties.source || "youtube").toLowerCase();
        /**
         * Playlist songs.
         * @type {Array<Song>}
         */
        this.songs = Array.isArray(info) ? info : info.items || info.songs;
        if (!Array.isArray(this.songs) || !this.songs.length) {
            throw new __1.DisTubeError("EMPTY_PLAYLIST");
        }
        this._patchMember(member || info.member);
        /**
         * Playlist name.
         * @type {string}
         */
        this.name =
            info.name ||
                info.title ||
                (this.songs[0].name
                    ? `${this.songs[0].name} and ${this.songs.length - 1} more songs.`
                    : `${this.songs.length} songs playlist`);
        /**
         * Playlist URL.
         * @type {string}
         */
        this.url = info.url || info.webpage_url;
        /**
         * Playlist thumbnail.
         * @type {?string}
         */
        this.thumbnail = ((_a = info.thumbnail) === null || _a === void 0 ? void 0 : _a.url) || info.thumbnail || this.songs[0].thumbnail;
        for (const [key, value] of Object.entries(properties)) {
            this[key] = value;
        }
        /**
         * Optional metadata that can be used to identify the playlist.
         * @type {T}
         */
        this.metadata = metadata;
        this._patchMetadata(metadata);
    }
    /**
     * Playlist duration in second.
     * @type {number}
     */
    get duration() {
        var _a;
        return ((_a = this.songs) === null || _a === void 0 ? void 0 : _a.reduce((prev, next) => prev + (next.duration || 0), 0)) || 0;
    }
    /**
     * Formatted duration string `hh:mm:ss`.
     * @type {string}
     */
    get formattedDuration() {
        return (0, __1.formatDuration)(this.duration);
    }
    /**
     * @param {?Discord.GuildMember} [member] Requested user
     * @private
     * @returns {Playlist}
     */
    _patchMember(member) {
        var _a;
        if (member) {
            /**
             * User requested.
             * @type {?Discord.GuildMember}
             */
            this.member = member;
            /**
             * User requested.
             * @type {?Discord.User}
             */
            this.user = (_a = this.member) === null || _a === void 0 ? void 0 : _a.user;
        }
        this.songs.map(s => s.constructor.name === "Song" && s._patchPlaylist(this, this.member));
        return this;
    }
    /**
     * @param {*} metadata Metadata
     * @private
     * @returns {Playlist}
     */
    _patchMetadata(metadata) {
        this.metadata = metadata;
        this.songs.map(s => s.constructor.name === "Song" && s._patchMetadata(metadata));
        return this;
    }
}
exports.Playlist = Playlist;
//# sourceMappingURL=Playlist.js.map